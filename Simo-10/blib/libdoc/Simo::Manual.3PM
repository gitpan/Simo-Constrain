.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Simo::Manual 3"
.TH Simo::Manual 3 "2009-04-11" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Simo::Manual \- Simo Manual
.SH "CAUTION"
.IX Header "CAUTION"
Now writing.
.PP
Please wait.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "Accessor options"
.IX Subsection "Accessor options"
\fIdefault option\fR
.IX Subsection "default option"
.PP
You can define default value of attribute.
.PP
.Vb 1
\&    sub title{ ac default => 'Perl is very interesting' }
.Ve
.PP
\fIconstrain option\fR
.IX Subsection "constrain option"
.PP
you can constrain setting value.
.PP
.Vb 1
\&    sub price{ ac constrain => sub{ /^\ed+$/ } }
.Ve
.PP
For example, If you call \f(CW$book\fR\->price( 'a' ), this call is die, because 'a' is not number.
.PP
\&'a' is set to \f(CW$_\fR. so if you can use regular expression, omit \f(CW$_\fR.
.PP
you can write not omiting \f(CW$_\fR.
.PP
.Vb 1
\&    sub price{ ac constrain => sub{ $_ > 0 && $_ < 3 } }
.Ve
.PP
If you display your message when program is die, you call craok.
.PP
.Vb 2
\&    use Carp;
\&    sub price{ ac constrain => sub{ $_ > 0 && $_ < 3 or croak "Illegal value" } }
.Ve
.PP
and 'a' is alse set to first argument. So you can receive 'a' as first argument.
.PP
.Vb 1
\&   sub price{ ac constrain => \e&_is_number }
.Ve
.PP
.Vb 4
\&   sub _is_number{
\&       my $val = shift;
\&       return $val =~ /^\ed+$/;
\&   }
.Ve
.PP
and you can define more than one constrain.
.PP
.Vb 1
\&    sub price{ ac constrain => [ \e&_is_number, \e&_is_non_zero ] }
.Ve
.PP
\fIfilter option\fR
.IX Subsection "filter option"
.PP
you can filter setting value.
.PP
.Vb 1
\&    sub description{ ac filter => sub{ uc } }
.Ve
.PP
setting value is \f(CW$_\fR and frist argument like constrain.
.PP
and you can define more than one filter.
.PP
.Vb 1
\&    sub description{ ac filter => [ \e&uc, \e&quoute ] }
.Ve
.PP
\fItrigger option\fR
.IX Subsection "trigger option"
.PP
You can define subroutine called after value is set.
.PP
For example, issue_datetime is set, issue_date is update.
.PP
$self is set to \f(CW$_\fR and \f(CW$_\fR[0] different from constrain and filter.
.PP
.Vb 2
\&    sub issue_datetime{ ac trigger => \e&update_issue_date }
\&    sub issue_date{ ac }
.Ve
.PP
.Vb 5
\&    sub update_issue_date{
\&        my $self = shift;
\&        my $date = substr( $self->issue_datetime, 0, 10 );
\&        $self->issue_date( $date );
\&    }
.Ve
.PP
and you can define more than one trigger.
.PP
.Vb 1
\&    sub issue_datetime{ ac trigger => [ \e&update_issue_date, \e&update_issue_time ] }
.Ve
.PP
\fIread_only option\fR
.IX Subsection "read_only option"
.PP
Read only accessor is defined
.PP
.Vb 1
\&    sub get_size{ ac default => 5, read_only => 1 }
.Ve
.PP
Accessor name should be contain 'get_'.If not, warnings is happen.
.PP
\fIhash_force option\fR
.IX Subsection "hash_force option"
.PP
If you pass array to accessor, Normally list convert to array ref.
    \f(CW$book\fR\->title( 'a' , 'b' ); # convert to [ 'a', 'b' ]
.PP
Even if you write
    \f(CW$book\fR\->title( a => 'b' )
.PP
( a => 'b' ) converted to [ 'a', 'b' ] 
.PP
If you use hash_force option, you convert list to hash ref
.PP
.Vb 1
\&    sub country_id{ ac hash_force => 1 }
.Ve
.PP
.Vb 1
\&    $book->title( a => 'b' ); # convert to { a => 'b' }
.Ve
.Sh "Order of constrain, filter and trigger"
.IX Subsection "Order of constrain, filter and trigger"
.IP "1. val is passed to constrain subroutine." 4
.IX Item "1. val is passed to constrain subroutine."
.PD 0
.IP "2. val is passed to filter subroutine." 4
.IX Item "2. val is passed to filter subroutine."
.IP "3. val is set" 4
.IX Item "3. val is set"
.IP "4. trigger subroutine is called" 4
.IX Item "4. trigger subroutine is called"
.PD
.PP
.Vb 5
\&       |---------|   |------|                  |-------| 
\&       |         |   |      |                  |       | 
\& val-->|constrain|-->|filter|-->(val is set)-->|trigger| 
\&       |         |   |      |                  |       | 
\&       |---------|   |------|                  |-------|
.Ve
.Sh "Get old value"
.IX Subsection "Get old value"
You can get old value when you use accessor as setter.
.PP
.Vb 2
\&    $book->author( 'Ken' );
\&    my $old_value = $book->author( 'Taro' ); # $old_value is 'Ken'
.Ve
.SH "MORE TECHNIQUE"
.IX Header "MORE TECHNIQUE"
.Sh "New method overriding"
.IX Subsection "New method overriding"
by default, new method receive key-value pairs.
But you can change this action by overriding new method.
.PP
For example, Point class. You want to call new method this way.
.PP
.Vb 1
\&    my $point = Point->new( 3, 5 ); # xPos and yPos
.Ve
.PP
You can override new method.
.PP
.Vb 2
\&    package Point;
\&    use Simo;
.Ve
.PP
.Vb 2
\&    sub new{
\&        my ( $self, $x, $y ) = @_; # two arg( not key-value pairs )
.Ve
.PP
.Vb 1
\&        # You can do anything if you need
.Ve
.PP
.Vb 2
\&        return $self->SUPER::new( x => $x, y => $y );
\&    }
.Ve
.PP
.Vb 3
\&    sub x{ ac }
\&    sub y{ ac }
\&    1;
.Ve
.PP
Simo implement inheritable new method.
Whenever You change argments or add initializetion,
You override new method.
.Sh "Extend base class"
.IX Subsection "Extend base class"
you may want to extend base class. It is \s-1OK\s0.
.PP
But I should say to you that there are one thing you should know.
The order of Inheritance is very important.
.PP
I write good sample and bad sample.
.PP
.Vb 3
\&    # base class
\&    package Book;
\&    sub title{ ac };
.Ve
.PP
.Vb 5
\&    # Good sample.
\&    # inherit base class. It is OK!
\&    package Magazine;
\&    use base 'Book'; # use base is first
\&    use Simo;        # use Simo is second;
.Ve
.PP
.Vb 4
\&    # Bad sample
\&    package Magazine;
\&    use Simo;          # use Simo is first
\&    use base 'Book';   # use base is second
.Ve
.PP
If you call new method in Good sample, you call Book::new method.
This is what you wanto to do.
.PP
If you call new method in Bad sample, you call Simo::new method. 
you will think why Book::new method is not called?
.PP
Maybe, You will be wrong sometime. So I recomend you the following writing.
.PP
.Vb 2
\&    package Magazine; use base 'Book'; # package and base class
\&    use Simo;
.Ve
.PP
It is like other language class Definition and I think looking is not bat.
and you are not likely to choose wrong order.
.Sh "new_self_and_parent"
.IX Subsection "new_self_and_parent"
new_self_and_parent resolve the inheritance of no Simo based class;
.PP
.Vb 5
\&    # no Simo based class
\&    package Book;
\&    sub new{
\&        my ( $proto, %args ) = @_;
\&        my $class = ref $proto || $proto;
.Ve
.PP
.Vb 2
\&        my $self = {};
\&        bless $self, $class;
.Ve
.PP
.Vb 2
\&        $self->{ title } = $args{ title };
\&        $self->{ author } = $args{ author };
.Ve
.PP
.Vb 2
\&        return $self;
\&    }
.Ve
.PP
.Vb 2
\&    package Magazine;
\&    use Simo( base => 'Book' );
.Ve
.PP
.Vb 2
\&    sub price{ ac }
\&    sub description{ ac }
.Ve
.PP
.Vb 3
\&    sub new{
\&        my ( $self, @args ) = @_;
\&        return $self->new_self_and_parent( @args, [ 'title', 'author' ] );
.Ve
